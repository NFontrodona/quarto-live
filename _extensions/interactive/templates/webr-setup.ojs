webROjs = {
  let { ExerciseEditor, WebREvaluator, EnvironmentManager, highlightR, replaceHighlightR } = window._webr_ojs_runtime;
  let { WebR, isRNull, isRCall, isRFunction, isRObject } = window._webr_ojs_runtime.WebR;

  const statusContainer = document.getElementById("exercise-loading-indicator");
  const statusText = document.getElementById("exercise-loading-status");

  // Hoist indicator out from final slide when running under reveal
  const revealStatus = document.querySelector(".reveal .exercise-loading-indicator");
  if (revealStatus) {
    revealStatus.remove();
    document.querySelector(".reveal > .slides").appendChild(revealStatus);
  }

  // Grab list of R packages to be pre-installed
  const pkgsContent = document.querySelector(`script[type=\"webr-packages\"]`).textContent;
  const pkgs = JSON.parse(atob(pkgsContent));

  // Grab list of resources to be downloaded
  const filesContent = document.querySelector(`script[type=\"webr-vfs-file\"]`).textContent;
  const files = JSON.parse(atob(filesContent));

  // Initialise webR and setup for R code evaluation
  let webRPromise = (async (webR) => {
    statusText.textContent = `Downloading webR`;
    await webR.init();

    // Install provided list of packages
    await pkgs.map((pkg) => () => {
      statusText.textContent = `Downloading package: ${pkg}`;
      return webR.installPackages([pkg]);
    }).reduce((cur, next) => cur.then(next), Promise.resolve());

    // Download and install resources
    await files.map((file) => async () => {
      statusText.textContent = `Downloading resource: ${file}`;
      const response = await fetch(file);
      if (!response.ok) {
        throw new Error(`Can't download \`${file}\`. Error ${response.status}: "${response.statusText}".`);
      }
      const data = await response.arrayBuffer();

      // Create directory tree, swallowing any `dir exists` errors
      let path = file;
      while (path = path.substr(0, path.lastIndexOf('/'))) {
        try {
          await webR.FS.mkdir(path);
        } catch (e) {
          if (!e.message.includes("FS error")) {
            throw e;
          }
        }
      }

      return await webR.FS.writeFile(file, new Uint8Array(data));
    }).reduce((cur, next) => cur.then(next), Promise.resolve());

    statusText.textContent = `Installing webR shims`;
    await webR.evalRVoid(`webr::shim_install()`);

    statusText.textContent = `WebR environment setup`;
    await webR.evalRVoid(`
      .webr_ojs <- new.env()
      ojs_define <- function(...) {
        args <- list(...)
        names(args) <- quote(match.call(expand.dots=TRUE)[1:length(args) + 1])
        .webr_ojs <<- list2env(args, envir = .webr_ojs)
      }
      options(webr.fig.width = 7, webr.fig.height = 5, knitr.table.format = "html")
      options(pager = function(files, ...) {
        writeLines(gsub(".[\b]", "", readLines(files)))
      })
      options(device = function(...) {
        args <- list(bg = "white", ...)
        args <- args[!duplicated(names(args))]
        do.call(webr::canvas, args)
      })
    `);

    statusContainer.classList.add("d-none");
    return webR;
  })(new WebR());

  // Convert webR R object reference to OJS value
  const asOjs = async (webRValue) => {
    const webR = await webRPromise;
    if (webRValue instanceof ImageBitmap) {
      const ctx = DOM.context2d(webRValue.width, webRValue.height, 1);
      ctx.drawImage(webRValue, 0, 0, webRValue.width, webRValue.height);
      webRValue.close();
      ctx.canvas.style.width = `${2 * ctx.canvas.width / 3}px`;
      return ctx.canvas;
    }

    if (!isRObject(webRValue)) {
      return webRValue;
    }

    // We have an R object, so grab knitr output to support asis, e.g. HTML.
    const capture = await webR.globalShelter.captureR(`
      knitr::knit_print(webRValue, options = list(screenshot.force = FALSE))
    `, { env: { webRValue } });
    webRValue = capture.result;

    if (isRFunction(webRValue) || isRCall(webRValue)) {
      // If there are images, return the final captured plot back to OJS.
      // Otherwise, return the captured R result value.
      // TODO: Handle returning result and (multiple) plots to OJS
      return async (...args) => {
          try {
            const width = await webR.evalRNumber('72 * getOption("webr.fig.width")');
            const height = await webR.evalRNumber('72 * getOption("webr.fig.height")');
            const capture = await webRValue.capture(
              {
                withAutoprint: true,
                captureGraphics: { width, height },
              },
              ...args
            );
            if (capture.images.length) {
              const el = await asOjs(capture.images[capture.images.length - 1]);
              el.value = await asOjs(capture.result);
              return el;
            }
            return await asOjs(capture.result);
          } finally {
            webR.globalShelter.purge();
          }
      };
    }

    switch (webRValue._payload.obj.type) {
        // TODO: "symbol"
        case "null":
          return null;

        case "character": {
          const classes = await (await webRValue.class()).toArray();
          if (classes.includes('knit_asis')) {
            var container = document.createElement('div');
            container.innerHTML = await webRValue.toString();
            return container.firstElementChild;
          }
        }
        case "logical":
        case "double":
        case "raw":
        case "integer":
          return await webRValue.toArray();

        case "list": {
          // Convert a `data.frame` to D3 format, otherwise fall through.
          const attrs = await webRValue.attrs();
          const cls = await attrs.get('class');
          if (!isRNull(cls) && (await cls.toArray()).includes('data.frame')) {
            return await webRValue.toD3();
          }
        }
        case "environment":
        case "pairlist": {
            const result = {};
            const shallow = await webRValue.toJs({ depth: -1 });
            for (let i = 0; i < shallow.values.length; i++) {
              const key = shallow.names ? shallow.names[i] : i;
              result[key] = await asOjs(shallow.values[i]);
            }
            return result;
        };

        default:
            throw new Error(`Unsupported type: ${webRValue._payload.obj.type}`);
    }
  }

  // Storage for shared exercise environments
  const environmentManager = new EnvironmentManager(webRPromise);

  // Keep track of initial OJS block render
  const renderedOjs = {};

  const process = async (context, inputs) => {
    const webR = await webRPromise;
    const envir = await environmentManager.get(context.options.envir);
    const code = context.code;
    const options = context.options;

    // Set OJS inputs in R environment
    await Promise.all(
      Object.entries(inputs).map(async ([k, v]) => {
        await envir.bind(k, v);
      })
    );

    const evaluator = new WebREvaluator(webR, environmentManager, context, inputs)

    try {
      await evaluator.evaluateQuietly(options.setup);
      await evaluator.evaluate(code);
    } finally {
      evaluator.purge();
    }

    // Grab objects from the webR OJS environment
    const ojs_envir = await webR.objs.globalEnv.get('.webr_ojs');
    const objs = await ojs_envir.toObject({ depth: -1 });

    // Grab objects from the evaluator environment
    if (typeof options.define === 'string') {
      objs[options.define] = await envir.get(options.define);
    } else if (options.define) {
      Object.assign(objs, Object.fromEntries(
        await Promise.all(
          options.define.map(async (name) => {
            const obj = await envir.get(name);
            return [name, obj];
          })
        )
      ));
    }

    // Define the objects as OJS values
    Object.keys(objs).forEach(async (key) => {
      const jsValue = await asOjs(objs[key]);
      if (window._ojs.ojsConnector.mainModule._scope.has(key)) {
        window._ojs.ojsConnector.mainModule.redefine(key, () => jsValue);
      } else {
        window._ojs.ojsConnector.define(key)(jsValue);
      }
    });

    // Clean up OJS values from R environment
    await webR.evalRVoid("rm(list = ls(.webr_ojs), envir = .webr_ojs)");

    // Return HTML output from the evaluator
    return evaluator.container;
  }

  return {
    ExerciseEditor,
    WebREvaluator,
    environmentManager,
    highlightR,
    process,
    replaceHighlightR,
    webRPromise,
    renderedOjs,
  };
}

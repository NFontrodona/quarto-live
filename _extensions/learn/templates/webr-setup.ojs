webROjs = {
  let { WebRExerciseEditor, WebREvaluator, WebREnvironmentManager, WebRGrader } = window._exercise_ojs_runtime;
  let { highlightR, interpolateR, setupR } = window._exercise_ojs_runtime;
  let { WebR, isRNull, isRCall, isRFunction, isRObject } = window._exercise_ojs_runtime.WebR;

  const statusContainer = document.getElementById("exercise-loading-indicator");
  const statusText = document.getElementById("exercise-loading-status");
  statusText.textContent = `Initialise`;
  statusContainer.classList.remove("d-none");

  // Hoist indicator out from final slide when running under reveal
  const revealStatus = document.querySelector(".reveal .exercise-loading-indicator");
  if (revealStatus) {
    revealStatus.remove();
    document.querySelector(".reveal > .slides").appendChild(revealStatus);
  }

  // Grab list of R packages to be pre-installed
  const pkgsContent = document.querySelector(`script[type=\"webr-packages\"]`).textContent;
  const packages = JSON.parse(atob(pkgsContent));

  // Grab list of resources to be downloaded
  const filesContent = document.querySelector(`script[type=\"vfs-file\"]`).textContent;
  const files = JSON.parse(atob(filesContent));

  // Other webR startup options
  const optionsContent = document.querySelector(`script[type=\"webr-options\"]`).textContent;
  const options = JSON.parse(atob(optionsContent));

  // Initialise webR and setup for R code evaluation
  let webRPromise = (async (webR) => {
    statusText.textContent = `Downloading webR`;
    await webR.init();

    // Install provided list of packages
    // Ensure webR default repo is included
    packages.repos.push("https://repo.r-wasm.org")
    await packages.pkgs.map((pkg) => () => {
      statusText.textContent = `Downloading package: ${pkg}`;
      return webR.evalR("webr::install(pkg, repos = repos)", { env: {
        pkg: pkg,
        repos: packages.repos,
      }});
    }).reduce((cur, next) => cur.then(next), Promise.resolve());

    // Download and install resources
    await files.map((file) => async () => {
      statusText.textContent = `Downloading resource: ${file}`;
      const response = await fetch(file);
      if (!response.ok) {
        throw new Error(`Can't download \`${file}\`. Error ${response.status}: "${response.statusText}".`);
      }
      const data = await response.arrayBuffer();

      // Create directory tree, swallowing any `dir exists` errors
      let path = file;
      while (path = path.substr(0, path.lastIndexOf('/'))) {
        try {
          await webR.FS.mkdir(path);
        } catch (e) {
          if (!e.message.includes("FS error")) {
            throw e;
          }
        }
      }

      return await webR.FS.writeFile(file, new Uint8Array(data));
    }).reduce((cur, next) => cur.then(next), Promise.resolve());

    statusText.textContent = `Installing webR shims`;
    await webR.evalRVoid(`webr::shim_install()`);

    statusText.textContent = `WebR environment setup`;
    await setupR(webR);

    statusContainer.classList.add("d-none");
    return webR;
  })(new WebR(options));

  // Storage for shared exercise environments
  const webREnvironmentManager = new WebREnvironmentManager(webRPromise);

  // Keep track of initial OJS block render
  const renderedOjs = {};

  const process = async (context, inputs) => {
    const webR = await webRPromise;
    const evaluator = new WebREvaluator(webR, webREnvironmentManager, context)
    await evaluator.process(inputs);
    return evaluator.container;
  }

  return {
    WebRExerciseEditor,
    WebREvaluator,
    WebRGrader,
    webREnvironmentManager,
    highlightR,
    process,
    interpolateR,
    webRPromise,
    renderedOjs,
  };
}

---
format: html
ojs-engine: true
filters:
  - webr_ojs_quarto.lua
---

<!-- TODO: To be included in Quarto/knitR itself -->
```{r echo=FALSE}
knitr::knit_engines$set(webr = function(options) {
  knitr:::one_string(c(
    paste0("```{.", options$original.params.src ,"}"),
    options$yaml.code,
    options$code,
    "```"
  ))
})
```

# Introduction

This is a standard Quarto R block. It is powered by `knitr`:

```{r}
x <- 1234
y <- 4567
x + y
c("a", "b", "c")
foo <- function (x) { 1 + sin(x); }
message("hi")
warning("hi")
hist(rnorm(100))
```

---

Now, here is a client-side R block. The output should be similar, but this one is powered by webR:

```{webr}
x <- 1234
y <- 4567
x + y
c("a", "b", "c")
foo <- function (x) { 1 + sin(x); }
message("hi")
warning("hi")
stop("a")
hist(rnorm(100))
```


## Accessing R's global environment from Observable

R objects defined in client-side webR blocks are accessible from Observable JS, Quarto dashboards, etc.

```{ojs}
x
y
foo([1, 2, 3, 4, 5])
```

Reactive inputs written in Observable JS can be used with the R objects provided by webR. You can write a function in R, then invoke it with reactive arguments.

R objects are converted to and from the JS environment transparently.

```{ojs}
viewof n = Inputs.range([0, 10], {step: 0.1, label: "Some n value:"})
res = foo(n)
"sin(n) = " + res[0]
```

---

Errors from R are converted into OJS errors:

```{ojs}
foo("abc")
```

## Converting Observable data frames to R `data.frame`

Here is an Observable dataset:

```{ojs}
alphabet
```

Observable JS data frames are converted into an R `data.frame` when passed as a function argument:

```{webr}
get_class <- function(x) { class(x) }
do_mean <- function(x) { mean(x[,2]) }
```

```{ojs}
get_class(alphabet)
do_mean(alphabet)
```


## Converting R `data.frames` to Observable

```{webr}
data(mtcars)
head(mtcars)
```

---

```{webr}
install.packages("dplyr", quiet = TRUE)
library(dplyr)
filtered_cars <- mtcars |> filter(hp > 123)
```

```{ojs}
Plot.plot({
  grid: true,
  x: {label: "Economy (mpg)"},
  y: {label: "Power (hp)"},
  marks: [ Plot.dot(filtered_cars, { x: "mpg", y: "hp"}) ]
})
```


## Plotting from R

We can write an R function outputs a plot and returns some result.

```{.webr}
do_hist <- function(n) {
  x <- rnorm(n)
  hist(x)
  mean(x)
}
```

Then, call that R function reactively from Observable JS:

```{ojs}
viewof m = Inputs.range([10, 1000], {step: 1})
viewof val = do_hist(m)
val
```

This gives very responsive interactivity with just a few lines of glue code.

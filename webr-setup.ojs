webROjs = {
  let { WebR, isRFunction, isRCall, isRNull, isRObject } = await import(
    'https://webr.r-wasm.org/v0.3.2/webr.mjs'
  );

  let { CodeMirrorEditor } = await import(
    '../quarto-contrib/webr-ojs-codemirror/webr-ojs-codemirror.js'
  );

  // Initialise webR and setup for R code evaluation
  let webR = new WebR();
  await webR.init();
  await webR.installPackages(['evaluate']);
  await webR.evalRVoid(`webr::shim_install()`);
  await webR.evalRVoid(`
    ojs_define <- function(...) {
      args <- list(...)
      names(args) <- quote(match.call(expand.dots=TRUE)[1:length(args) + 1])
      invisible(list2env(args, envir = .GlobalEnv))
    }
    options(webr.fig.width = 7, webr.fig.height = 5)
  `);

  // Convert webR R object reference to OJS value
  const asOjs = async (webRValue) => {
    if (webRValue instanceof ImageBitmap) {
      const ctx = DOM.context2d(webRValue.width, webRValue.height, 1);
      ctx.drawImage(webRValue, 0, 0, webRValue.width, webRValue.height);
      webRValue.close();
      ctx.canvas.style.width = `${2 * ctx.canvas.width / 3}px`;
      return ctx.canvas;
    }

    if (!isRObject(webRValue)) {
      return webRValue;
    }

    if (isRFunction(webRValue) || isRCall(webRValue)) {
      return async (...args) => {
          try {
            const width = await webR.evalRNumber('72 * getOption("webr.fig.width")');
            const height = await webR.evalRNumber('72 * getOption("webr.fig.height")');
            const capture = await webRValue.capture(
              {
                withAutoprint: true,
                captureGraphics: { width, height },
              },
              ...args
            );
            
            // If there are images, return the final captured plot back to OJS.
            // Otherwise, return the captured R result value.
            // TODO: Handle returning result and (multiple) plots to OJS
            if (capture.images.length) {
              const el = await asOjs(capture.images[capture.images.length - 1]);
              el.value = await asOjs(capture.result);
              return el;
            }
            return await asOjs(capture.result);
          } finally {
            webR.globalShelter.purge();
          }
      };
    }

    switch (webRValue._payload.obj.type) {
        // TODO: "symbol"
        case "null":
          return null;

        case "logical":
        case "double":
        case "character":
        case "raw":
        case "integer":
          return await webRValue.toArray();

        case "list": {
          // Convert a `data.frame` to D3 format, otherwise fall through.
          const attrs = await webRValue.attrs();
          const cls = await attrs.get('class');
          if (!isRNull(cls) && (await cls.toArray()).includes('data.frame')) {
            return await webRValue.toD3();
          }
        }
        case "environment":
        case "pairlist": {
            const result = {};
            const shallow = await webRValue.toJs({ depth: -1 });
            for (let i = 0; i < shallow.names.length; i++) {
                result[shallow.names[i]] = await asOjs(shallow.values[i]);
            }
            return result;
        };

        default:
            throw new Error(`Unsupported type: ${webRValue._payload.obj.type}`);
    }
  }

  // Build interleaved source code and HTML output
  // Use {evaluate}, so as to match {knitr} output
  class WebREvaluator {
    constructor(envir = webR.objs.globalEnv) {
      this.output = document.createElement('div');
      this.sourceLines = [];
      this.shelter = new webR.Shelter();
      this.envir = envir;
    }

    async purge() {
      const shelter = await this.shelter;
      shelter.purge();
    }
    
    async evaluate(code) {
      const shelter = await this.shelter;
      const envir = await this.envir;

      const capture = await shelter.captureR(
        'evaluate::evaluate(code, envir = envir)',
        { env: { code, envir } }
      );

      const result = await capture.result.toArray();
      for (let i = 0; i < result.length; i++) {
        const type = await result[i].type();
        switch (type) {
          case 'character': {
            this.appendStdout(await result[i].toString());
            break;
          }
          case 'list': {
            const attrs = await result[i].attrs();
            const classList = await (await attrs.get('class')).toArray();
            
            // Conditions
            if (classList.includes('warning')) {
              const message = await result[i].get("message");
              this.appendStderr(`Warning: ${await message.toString()}`);
            } else if (classList.includes('error')) {
              const message = await result[i].get("message");
              const call = await result[i].get("call");
              const callInfo = await call.type() === "null" ? '' : ` in \`${await call.deparse()}\`: `;
              this.appendStderr(`Error${callInfo}${await message.toString()}`);
            } else if (classList.includes('condition')) {
              const message = await result[i].get("message");
              this.appendStderr(await message.toString());
            }
  
            // Source code - save for concatenation
            if (classList.includes('source')) {
              const src = await result[i].get("src");
              this.sourceLines.push(await src.toString());
            }
            
            // Plot image
            if (classList.includes('recordedplot')) {
              const width = await webR.evalRNumber('72 * getOption("webr.fig.width")');
              const height = await webR.evalRNumber('72 * getOption("webr.fig.height")');
              const capturePlot = await shelter.captureR("replayPlot(plot)", {
                captureGraphics: { width, height },
                env: { plot: result[i] },
              });
              this.appendImage(capturePlot.images[0]);
            }
            break;
          }
          default:
            throw new Error(`Unexpected list item type "${type}" in evaluation result`);
        }
      }
      this.appendSource();
    }
    
    appendSource() {
      if (this.sourceLines.length) {
        const sourceDiv = document.createElement("div");
        const sourcePre = document.createElement("pre");
        const sourceCode = document.createElement("code");
        sourceDiv.className = "sourceCode";
        sourcePre.className = "sourceCode r";
        sourceCode.className = "sourceCode r";
        
        this.sourceLines.forEach((line) => {
          const sourceSpan = document.createElement("span");
          sourceSpan.textContent = line;
          sourceCode.appendChild(sourceSpan);
        });
        this.sourceLines.length = 0;
        
        sourcePre.appendChild(sourceCode);
        sourceDiv.appendChild(sourcePre);
        this.output.appendChild(sourceDiv);
      }
    }
    
    appendStdout(content) {
      const outputDiv = document.createElement("div");
      outputDiv.className = "cell-output cell-output-stdout";
      outputDiv.innerHTML = `<pre><code>${content}</code></pre>`;

      this.appendSource();
      this.output.appendChild(outputDiv);
    }
    
    appendStderr(content) {
      const outputDiv = document.createElement("div");
      outputDiv.className = "cell-output cell-output-stderr";
      outputDiv.innerHTML = `<pre><code>${content}</code></pre>`;

      this.appendSource();
      this.output.appendChild(outputDiv);
    }
    
    appendImage(image) {
      const canvas = document.createElement('canvas');
      canvas.width = image.width;
      canvas.height = image.height;
      canvas.className = "img-fluid figure-img";
      canvas.style.width = `${2 * image.width / 3}px`;
      canvas.getContext('bitmaprenderer').transferFromImageBitmap(image);
      
      const outputDiv = document.createElement("div");
      outputDiv.className = "cell-output-display";
      outputDiv.appendChild(canvas);

      this.appendSource();
      this.output.appendChild(outputDiv);
    }
  }

  // Create an interactive R code editor
  const editor = (code) => {
    if (typeof code !== "string") {
      throw new Error("Can't create editor, `code` must be a string.");
    }

    const editor = new CodeMirrorEditor({
      doc: code,
    });

    const el = editor.view.dom;
    el.value = editor.view.state.doc.toString();
    return el;
  }

  // Evaluate the provided R code in the given environment
  const evaluate = async (code, envir = webR.objs.globalEnv) => {
    const evaluator = new WebREvaluator(envir);
    try {
      await evaluator.evaluate(code);
    } finally {
      evaluator.purge();
    }

    // Define objects in the global environment as OJS values
    const objs = await envir.toJs({ depth: -1 });
    for (let i = 0; i < objs.names.length; i++) {
      const key = objs.names[i];
      const value = objs.values[i];
      const jsValue = await asOjs(value);
      if (window._ojs.ojsConnector.mainModule._scope.has(key)) {
        window._ojs.ojsConnector.mainModule.redefine(key, () => jsValue);
      } else {
        window._ojs.ojsConnector.define(key)(jsValue);
      }
    }

    return evaluator.output;
  }

  return { webR, asOjs, WebREvaluator, editor, evaluate };
}

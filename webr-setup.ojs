shelter = {
  let {
    WebR,
    isRFunction,
    isRCall,
    isRNull,
    isRObject
  } = await import('https://webr.r-wasm.org/v0.3.0-rc.0/webr.mjs');

  let webR = new WebR();
  await webR.init();
  const shelter = await new webR.Shelter();
  await shelter.evalR(`
    ojs_define <- function(...) {
      args <- list(...)
      names(args) <- quote(match.call(expand.dots=TRUE)[1:length(args) + 1])
      list2env(LIST, envir = .GlobalEnv)
    }
  `);

  const webRScriptContent = document.querySelector("script[type=\"webr-contents\"]").textContent;
  const webRBlocks = JSON.parse(atob(webRScriptContent)).blocks;
  for (const block of webRBlocks) {
    try {
      await shelter.evalR(block.source);
    } catch (e) {
      console.error(e);
    }
  }

  const objs = await webR.objs.globalEnv.toJs({ depth: -1 });

  const asOjs = async (webRValue) => {
    if (webRValue instanceof ImageBitmap) {
      const ctx = DOM.context2d(webRValue.width, webRValue.height, 1);
      ctx.drawImage(webRValue, 0, 0, webRValue.width, webRValue.height);
      webRValue.close();
      ctx.canvas.style.width = "100%";
      return ctx.canvas;
    }

    if (!isRObject(webRValue)) {
        return webRValue;
    }

    if (isRFunction(webRValue) || isRCall(webRValue)) {
        return async (...args) => {
            const webRCapture = await webRValue.capture({ withAutoprint: true }, ...args);
            if (webRCapture.images.length) {
              return await asOjs(webRCapture.images[webRCapture.images.length - 1]);
            }
            return await asOjs(webRCapture.result);
        };
    }

    switch (webRValue._payload.obj.type) {
        case "null": return null;
        // Symbol: TBD
        case "logical":
        case "double":
        case "character":
        case "raw":
        case "integer": return await webRValue.toArray();

        case "list": {
          const attrs = await webRValue.attrs();
          const cls = await attrs.get('class');
          if (!isRNull(cls) && (await cls.toArray()).includes('data.frame')) {
            return await webRValue.toD3();
          }
        }
        case "environment":
        case "pairlist": {
            const result = {};
            const shallow = await webRValue.toJs({ depth: -1 });
            for (let i = 0; i < shallow.names.length; i++) {
                result[shallow.names[i]] = await asOjs(shallow.values[i]);
            }
            return result;
        };

        default:
            throw new Error(`Unsupported type: ${webRValue._payload.obj.type}`);

    }
  }
  for (let i = 0; i < objs.names.length; i++) {
    const key = objs.names[i];
    const value = objs.values[i];
    window._ojs.ojsConnector.define(key)(await asOjs(value));
  }
  return shelter;
}

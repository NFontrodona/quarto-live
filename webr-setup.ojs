webROjs = {
  let { WebR, isRFunction, isRCall, isRNull, isRObject } = await import(
    'https://webr.r-wasm.org/latest/webr.mjs'
  );

  let { CodeMirrorEditor } = await import(
    '../quarto-contrib/webr-ojs-codemirror/webr-ojs-codemirror.js'
  );

  // Initialise webR and setup for R code evaluation
  let webR = new WebR();
  await webR.init();
  await webR.installPackages(['evaluate', 'knitr']);
  await webR.evalRVoid(`webr::shim_install()`);
  await webR.evalRVoid(`
    ojs_define <- function(...) {
      args <- list(...)
      names(args) <- quote(match.call(expand.dots=TRUE)[1:length(args) + 1])
      invisible(list2env(args, envir = .GlobalEnv))
    }
    options(webr.fig.width = 7, webr.fig.height = 5)
  `);

  // Convert webR R object reference to OJS value
  const asOjs = async (webRValue) => {
    if (webRValue instanceof ImageBitmap) {
      const ctx = DOM.context2d(webRValue.width, webRValue.height, 1);
      ctx.drawImage(webRValue, 0, 0, webRValue.width, webRValue.height);
      webRValue.close();
      ctx.canvas.style.width = `${2 * ctx.canvas.width / 3}px`;
      return ctx.canvas;
    }

    if (!isRObject(webRValue)) {
      return webRValue;
    }

    // We have an R object, so grab knitr output to support asis, e.g. HTML.
    const capture = await webR.globalShelter.captureR(`
      knitr::knit_print(webRValue, options = list(screenshot.force = FALSE))
    `, { env: { webRValue } });
    webRValue = capture.result;

    if (isRFunction(webRValue) || isRCall(webRValue)) {
      // If there are images, return the final captured plot back to OJS.
      // Otherwise, return the captured R result value.
      // TODO: Handle returning result and (multiple) plots to OJS
      return async (...args) => {
          try {
            const width = await webR.evalRNumber('72 * getOption("webr.fig.width")');
            const height = await webR.evalRNumber('72 * getOption("webr.fig.height")');
            const capture = await webRValue.capture(
              {
                withAutoprint: true,
                captureGraphics: { width, height },
              },
              ...args
            );
            if (capture.images.length) {
              const el = await asOjs(capture.images[capture.images.length - 1]);
              el.value = await asOjs(capture.result);
              return el;
            }
            return await asOjs(capture.result);
          } finally {
            webR.globalShelter.purge();
          }
      };
    }

    switch (webRValue._payload.obj.type) {
        // TODO: "symbol"
        case "null":
          return null;

        case "character": {
          const classes = await (await webRValue.class()).toArray();
          if (classes.includes('knit_asis')) {
            var container = document.createElement('div');
            container.innerHTML = await webRValue.toString();
            return container.firstElementChild;
          }
        }
        case "logical":
        case "double":
        case "raw":
        case "integer":
          return await webRValue.toArray();

        case "list": {
          // Convert a `data.frame` to D3 format, otherwise fall through.
          const attrs = await webRValue.attrs();
          const cls = await attrs.get('class');
          if (!isRNull(cls) && (await cls.toArray()).includes('data.frame')) {
            return await webRValue.toD3();
          }
        }
        case "environment":
        case "pairlist": {
            const result = {};
            const shallow = await webRValue.toJs({ depth: -1 });
            for (let i = 0; i < shallow.values.length; i++) {
              const key = shallow.names ? shallow.names[i] : i;
              result[key] = await asOjs(shallow.values[i]);
            }
            return result;
        };

        default:
            throw new Error(`Unsupported type: ${webRValue._payload.obj.type}`);
    }
  }

  // Build interleaved source code and HTML output
  // Use {evaluate}, so as to match {knitr} output
  class WebREvaluator {
    constructor(options = {}) {
      this.output = document.createElement('div');
      this.sourceLines = [];
      this.shelter = new webR.Shelter();

      // Fallback default options
      this.options = Object.assign(
        {
          envir: webR.objs.globalEnv,
          eval: true,
          echo: true,
          warning: true,
          error: true,
          include: true,
          output: true,
        },
        options
      );
    }

    static async process(code, options) {
      const evaluator = new WebREvaluator(options);
      try {
        await evaluator.evaluate(code);
      } finally {
        evaluator.purge();
      }

      // Define objects in the evaluator environment as OJS values
      const objs = await options.envir.toJs({ depth: -1 });
      for (let i = 0; i < objs.names.length; i++) {
        const key = objs.names[i];
        const value = objs.values[i];
        const jsValue = await asOjs(value);
        if (window._ojs.ojsConnector.mainModule._scope.has(key)) {
          window._ojs.ojsConnector.mainModule.redefine(key, () => jsValue);
        } else {
          window._ojs.ojsConnector.define(key)(jsValue);
        }
      }

      return evaluator.output;
    }

    async purge() {
      const shelter = await this.shelter;
      shelter.purge();
    }
    
    async evaluate(code) {
      // Early returns if we're not actually evaluating
      if (!this.options.include) {
        return;
      }

      if (!this.options.eval) {
        this.sourceLines.push(code);
        this.appendSource();
        return;
      }

      const shelter = await this.shelter;
      const capture = await shelter.captureR(
        `evaluate::evaluate(
          code,
          envir = envir,
          keep_message = warning,
          keep_warning = warning,
          stop_on_error = error,
          output_handler = evaluate::new_output_handler(
            value = function(x) {
              res <- withVisible(knitr::knit_print(x, options = list(screenshot.force = FALSE)))
              if (res$visible) res$value else invisible(res$value)
            }
          )
        )`,
        {
          env: {
            code,
            envir: this.options.envir,
            warning: this.options.warning,
            error: this.options.error ? 0 : 1,
          }
        }
      );

      const result = await capture.result.toArray();
      for (let i = 0; i < result.length; i++) {
        const type = await result[i].type();
        switch (type) {
          case 'character': {
            const classes = await (await result[i].class()).toArray();
            const output = await result[i].toString();
            if (classes.includes('knit_asis')) {
              this.appendHtml(await result[i].toString());
            } else {
              this.appendStdout(await result[i].toString());
            }
            break;
          }
          case 'list': {
            const attrs = await result[i].attrs();
            const classList = await (await attrs.get('class')).toArray();
            
            // Conditions
            if (classList.includes('warning')) {
              const message = await result[i].get("message");
              this.appendStderr(`Warning: ${await message.toString()}`);
            } else if (classList.includes('error')) {
              const message = await result[i].get("message");
              const call = await result[i].get("call");
              const callInfo = await call.type() === "null" ? '' : ` in \`${await call.deparse()}\`: `;
              this.appendStderr(`Error${callInfo}${await message.toString()}`);
            } else if (classList.includes('condition')) {
              const message = await result[i].get("message");
              this.appendStderr(await message.toString());
            }
  
            // Source code - save for concatenation
            if (classList.includes('source')) {
              const src = await result[i].get("src");
              this.sourceLines.push(await src.toString());
            }
            
            // Plot image
            if (classList.includes('recordedplot')) {
              const width = await webR.evalRNumber('72 * getOption("webr.fig.width")');
              const height = await webR.evalRNumber('72 * getOption("webr.fig.height")');
              const capturePlot = await shelter.captureR("replayPlot(plot)", {
                captureGraphics: { width, height },
                env: { plot: result[i] },
              });
              this.appendImage(capturePlot.images[0]);
            }
            break;
          }
          default:
            throw new Error(`Unexpected list item type "${type}" in evaluation result`);
        }
      }
      this.appendSource();
    }
    
    appendSource() {
      if (this.options.echo && this.sourceLines.length) {
        const sourceDiv = document.createElement("div");
        const sourcePre = document.createElement("pre");
        const sourceCode = document.createElement("code");
        sourceDiv.className = "sourceCode";
        sourcePre.className = "sourceCode r";
        sourceCode.className = "sourceCode r";
        
        this.sourceLines.forEach((line) => {
          const sourceSpan = document.createElement("span");
          sourceSpan.textContent = line;
          sourceCode.appendChild(sourceSpan);
        });

        sourcePre.appendChild(sourceCode);
        sourceDiv.appendChild(sourcePre);
        this.output.appendChild(sourceDiv);
      }
      this.sourceLines.length = 0;
    }
    
    appendStdout(content) {
      const outputDiv = document.createElement("div");
      outputDiv.className = "cell-output cell-output-stdout";
      outputDiv.innerHTML = `<pre><code>${content}</code></pre>`;

      if (this.options.output) {
        this.appendSource();
        this.output.appendChild(outputDiv);
      }
    }
    
    appendStderr(content) {
      const outputDiv = document.createElement("div");
      outputDiv.className = "cell-output cell-output-stderr";
      outputDiv.innerHTML = `<pre><code>${content}</code></pre>`;

      if (this.options.output) {
        this.appendSource();
        this.output.appendChild(outputDiv);
      }
    }

    appendHtml(content) {
      const outputDiv = document.createElement("div");
      outputDiv.className = "cell-output";
      outputDiv.innerHTML = content;

      if (this.options.output) {
        this.appendSource();
        this.output.appendChild(outputDiv);
      }
    }
    
    appendImage(image) {
      const canvas = document.createElement('canvas');
      canvas.width = image.width;
      canvas.height = image.height;
      canvas.className = "img-fluid figure-img";
      canvas.style.width = `${2 * image.width / 3}px`;
      canvas.getContext('bitmaprenderer').transferFromImageBitmap(image);
      
      const outputDiv = document.createElement("div");
      outputDiv.className = "cell-output-display";
      outputDiv.appendChild(canvas);

      if (this.options.output) {
        this.appendSource();
        this.output.appendChild(outputDiv);
      }
    }
  }

  // Create an interactive R code editor
  const editor = (code, options) => {
    if (typeof code !== "string") {
      throw new Error("Can't create editor, `code` must be a string.");
    }

    const editor = new CodeMirrorEditor(code, options);
    const el = editor.view.dom;
    el.value = {
      code: editor.view.state.doc.toString(),
      options,
    }
    return el;
  }

  return { webR, asOjs, WebREvaluator, editor };
}

webROjs = {
  let { WebR, isRFunction, isRCall, isRNull, isRObject } = await import(
    'https://webr.r-wasm.org/v0.3.0/webr.mjs'
  );

  let webR = new WebR();
  await webR.init();
  await webR.installPackages(['evaluate']);
  await webR.evalRVoid(`
    ojs_define <- function(...) {
      args <- list(...)
      names(args) <- quote(match.call(expand.dots=TRUE)[1:length(args) + 1])
      list2env(LIST, envir = .GlobalEnv)
    }
    options(webr.fig.width = 7, webr.fig.height = 5)
  `);

  const shelter = await new webR.Shelter();
  const evalCanvas = await shelter.evalR(`
    function(fn, ...) {
      webr::canvas(
        width = 72 * getOption("webr.fig.width"),
        height = 72 * getOption("webr.fig.height"),
        capture = TRUE
      )
      capture_dev = dev.cur();
      fn(...)
      dev.off(capture_dev)
    }
  `);

  const asOjs = async (webRValue) => {
    if (webRValue instanceof ImageBitmap) {
      const ctx = DOM.context2d(webRValue.width, webRValue.height, 1);
      ctx.drawImage(webRValue, 0, 0, webRValue.width, webRValue.height);
      webRValue.close();
      ctx.canvas.style.width = `${2 * ctx.canvas.width / 3}px`;
      return ctx.canvas;
    }

    if (!isRObject(webRValue)) {
      return webRValue;
    }

    if (isRFunction(webRValue) || isRCall(webRValue)) {
      return async (...args) => {
          try {
            const capture = await evalCanvas.capture(
              { withAutoprint: true },
              webRValue,
              ...args
            );
            if (capture.images.length) {
              return await asOjs(capture.images[capture.images.length - 1]);
            }
            return await asOjs(capture.result);
          } finally {
            webR.globalShelter.purge();
          }
      };
    }

    switch (webRValue._payload.obj.type) {
        case "null": return null;
        // Symbol: TBD
        case "logical":
        case "double":
        case "character":
        case "raw":
        case "integer": return await webRValue.toArray();

        case "list": {
          const attrs = await webRValue.attrs();
          const cls = await attrs.get('class');
          if (!isRNull(cls) && (await cls.toArray()).includes('data.frame')) {
            return await webRValue.toD3();
          }
        }
        case "environment":
        case "pairlist": {
            const result = {};
            const shallow = await webRValue.toJs({ depth: -1 });
            for (let i = 0; i < shallow.names.length; i++) {
                result[shallow.names[i]] = await asOjs(shallow.values[i]);
            }
            return result;
        };

        default:
            throw new Error(`Unsupported type: ${webRValue._payload.obj.type}`);
    }
  }

  return { webR, isRFunction, isRCall, isRNull, isRObject, asOjs, shelter, evalCanvas };
}
